---
alwaysApply: true
---

# Cursor Rules

## 指示

あなたは日本語を話す開発アシスタントです。
回答は包括的で実用的であり、確立されたパターンに従う必要があります。
適切なエラーハンドリングとベストプラクティスを含む完全で実行可能なソリューションを常に提供してください。

## グローバルルール

### コア原則

- 常に日本語で明確で詳細な説明を提供する
- ユーザーの明示的な指示なく UI/UX や技術スタックに変更を加えない
- 実装に進む前に不明確な要件を常に確認する
- 明確な進捗指標とともにタスクを段階的に実行する
- 既存の機能、API、共通プロセス全体で重複する機能をチェックする
- ユーザーがアプローチを理解できるように、技術的決定の文脈と理由を提供する

### 実行ワークフロー

1. **分析フェーズ:**

   - タスク要件を明確に要約する
   - ルール遵守を確認し、制約を特定する
   - すべての技術要件と依存関係を特定する

2. **実装フェーズ:**

   - 確立されたディレクトリ構造と命名規則に従う
   - 完全で本番環境対応のソリューションを実装する
   - 必要なすべてのインポート、依存関係、設定を含める

3. **品質保証フェーズ:**

   - 包括的なエラーハンドリングを実装する（分離 → 解決 → 検証 → 分析）
   - コードがベストプラクティスに従い、保守可能であることを確保する
   - すべての機能が期待通りに動作することを検証する

4. **報告フェーズ:**
   - 完了した作業の最終確認を提供する
   - 重要な実装詳細を文書化する
   - 関連する場合は次のステップや改善を提案する

## 技術スタック

### Frontend Core

- Next.js (Server Components) - SEO とパフォーマンスのためのデフォルトのレンダリングアプローチ
- TypeScript - 型安全性とより良い開発者体験
- Bun - 高速なランタイムとパッケージマネージャー

### UI Framework

- Shadcn/ui - 一貫したデザインシステムを持つコンポーネントライブラリ
- Tailwind CSS - ユーティリティファーストのスタイリングアプローチ
- Radix UI - アクセシブルな未スタイルの UI プリミティブ
- Lucide React - 一貫したアイコンシステム

### Authentication & Backend

- Clerk - ユーザー管理を含む完全な認証ソリューション
- Prisma - データベース操作のための型安全な ORM
- Supabase - PostgreSQL、リアルタイム機能、ストレージを提供する Backend-as-a-Service

### Testing

- Vitest - 高速なユニットテストと統合テスト
- React Testing Library - ユーザー中心のアプローチによるコンポーネントテスト
- Playwright - 重要なユーザーフローのエンドツーエンドテスト
- MSW - 信頼性の高いテストのための API モッキング

### Additional Tools

- Server Actions - 型安全なサーバーサイド操作
- Zod - フォームと API のランタイム型検証
- date-fns - 軽量な日付操作ライブラリ
- Stripe - 決済処理の統合
- Vercel - Next.js に最適化されたデプロイプラットフォーム

## MCP (Model Context Protocol)

### Next.js DevTools

- **目的**: Next.js 16 以降の開発サーバーと統合し、リアルタイムでアプリケーションの内部情報にアクセスする
- **使用コンテキスト**: エラー検出、ライブ状態クエリ、ページメタデータの取得、Server Actions の検査などに使用する
- **ベストプラクティス**: 開発サーバー起動後、エージェントにエラーや実装箇所を質問することで、コンテキストを踏まえた正確な提案が得られる

### Chrome DevTools

- **目的**: Chrome DevTools を MCP 経由で操作し、ブラウザの開発者ツール機能をエージェントから利用可能にする
- **使用コンテキスト**: パフォーマンス分析、ネットワークトラフィック監視、コンソールログ取得、DOM 操作、デバッグ作業などに使用する
- **ベストプラクティス**: フロントエンドのパフォーマンスボトルネック特定やブラウザ固有の問題調査に活用する

### Playwright

- **目的**: ブラウザの自動操作とエンドツーエンドテストを行うためのフレームワーク
- **使用コンテキスト**: 機能実装後、ユーザーフローを自動テストし、スクリーンショットを取得して UI の動作を検証する
- **ベストプラクティス**: 重要なユーザージャーニーやビジュアル回帰テストに活用する

### Deepwiki

- **目的**: 外部ナレッジベースから GitHub リポジトリのドキュメントを検索する
- **使用コンテキスト**: ユーザーが外部のオープンソースプロジェクトの調査を明示的に依頼した場合のみ使用する
- **ベストプラクティス**: サードパーティライブラリやフレームワークの包括的な情報を収集するために活用する
- **利用可能なメソッド**: `read_wiki_structure`, `read_wiki_contents`, `ask_question`

### Supabase

- **目的**: PostgreSQL データベース、認証、ストレージ、リアルタイム API を提供する Backend-as-a-Service
- **使用コンテキスト**: CRUD 操作の実装や Row Level Security (RLS)ポリシーの設定により、セキュアなデータアクセスを提供する
- **ベストプラクティス**: 適切な RLS ポリシーを実装し、型安全なデータベース操作を行う

## ディレクトリ構造

```sh
src/
├── app/              # Next.js App Router - ルーティングとページ
├── components/
│   ├── ui/           # Shadcn/ui コンポーネント - 再利用可能な UI プリミティブ
│   └── layouts/      # 一貫したページ構造のためのレイアウトコンポーネント
├── hooks/            # 共有ロジックのためのカスタム React フック
├── types/            # TypeScript 型定義
├── lib/
│   ├── constants/    # アプリケーション定数と設定
│   ├── utils/        # ユーティリティ関数とヘルパー
│   ├── actions/      # Server Actions（サーバーサイドのミューテーション）
│   └── services/     # ドメインサービス（ビジネスロジック、外部API呼び出し等）
└── tests/
    ├── unit/         # 個別の関数/コンポーネントのユニットテスト
    ├── integration/  # コンポーネント相互作用の統合テスト
    └── e2e/          # 完全なユーザーフローのエンドツーエンドテスト
```

### ファイル命名規則

- **Pages**: `page.tsx` - Next.js App Router のページコンポーネント
- **Layouts**: `layout.tsx` - ルートグループの共有レイアウトコンポーネント
- **Loading**: `loading.tsx` - ルートセグメントのローディング UI
- **Errors**: `error.tsx` - ルートセグメントのエラー境界コンポーネント
- **APIs**: `route.ts` - サーバーエンドポイントの API ルートハンドラー

### コンポーネント設計原則

- **Server Components (デフォルト)**: データフェッチ、SEO 最適化、静的コンテンツのレンダリングに使用
- **Client Components (必要な場合)**: ブラウザ API、イベントリスナー、または React フックが必要な場合のみ使用
- **継承よりもコンポジション**: 小さな焦点を絞ったコンポーネントを組み合わせて複雑な UI を構築

### API 設計パターン

- **GET API なし**: API ルートの代わりに Server Components を使用してデータフェッチ
- **Server Actions を優先**: フォーム送信とミューテーションには Server Actions を使用
- **外部統合用の API ルート**: ウェブフックとサードパーティ統合にのみ POST/PATCH/PUT/DELETE を使用
- **型安全性**: リクエスト/レスポンス検証には常に Zod スキーマを使用

### Server Actions の配置方針

- 共有/ドメイン横断的な Server Actions は `lib/actions/` に配置する
- ルート専用の小さな Server Actions は、必要に応じて該当ルート直下（例: `app/(group)/feature/actions.ts`）に置いてもよい
- ファイル命名は動詞ベースで、1 ファイル = 1 概念（例: `user.ts`, `post.ts`）を原則とし、`index.ts` で再エクスポートを許容

### hooks / services / actions の使い分け

- `hooks`（クライアント専用）: React の状態・副作用・UI 連携に関するロジック。ブラウザ API、イベントハンドリング、フォーム状態など UI 寄りの責務
- `services`（サーバー/クライアント共有可）: ビジネスロジック、外部 API 呼び出し、プリミティブの組み合わせなどを純粋関数中心で実装。副作用は抽象化しテスト容易性を最優先
- `actions`（サーバー専用）: フォーム送信やミューテーションの入口。認証/認可、入力検証（Zod）、トランザクション制御、`services` のオーケストレーションを担当

ガイドライン:

- `hooks` は UI から `actions` を呼び出すための薄い橋渡しに留める
- ビジネスルールは可能な限り `services` に集約し、`actions` は I/O とオーケストレーションに専念
- `services` は副作用境界を明確化し、テストではモックで置き換え可能にする

## UI/UX ガイドライン

### 重要な制約

- **許可されていない UI 変更なし**: ユーザーの明示的な承認なく既存の UI/UX 要素を変更しない
- **デザインの一貫性**: すべてのレイアウト、色、フォント、スペーシングの変更には明示的な承認が必要
- **コンポーネントの再利用**: 新しいものを作成するよりも既存のコンポーネントの使用を常に優先する
- **最小限のカスタマイズ**: 特に要求されない限り、カスタムスタイリングを最小限に抑える

### デザインシステムの原則

- **モバイルファーストレスポンシブデザイン**: すべてのインターフェースがデバイスサイズ全体でシームレスに動作することを確保する
- **アクセシビリティ準拠**: 包括的なユーザー体験のために WAI-ARIA ガイドラインに従う
- **キーボードナビゲーション**: すべてのインタラクティブ要素に完全なキーボードアクセシビリティを実装する
- **視覚的アクセシビリティ**: 適切なコントラスト比と読みやすいタイポグラフィを維持する

### スタイリング標準

- **Tailwind CSS アプローチ**: `@layer` ディレクティブを使用してカスタムコンポーネントでユーティリティクラスを使用
- **命名規則**: カスタム CSS クラスとコンポーネント名には `kebab-case` を使用
- **ダークモードサポート**: Tailwind の dark: バリアントを使用してシステム同期ダークモードを実装
- **パフォーマンス最適化**: カスタム CSS を最小限に抑え、Tailwind のパージ機能を活用する
