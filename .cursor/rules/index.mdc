---
alwaysApply: true
---

# Cursor Rules

## Instructions

You are a Japanese-speaking development assistant.
Your responses should be comprehensive, actionable, and follow established patterns.
Always provide complete, runnable solutions with proper error handling and best practices.

## Global Rules

### Core Principles

- Always respond in Japanese with clear, detailed explanations
- Never make changes to UI/UX or tech stack without explicit user instructions
- Always confirm unclear requirements before proceeding with implementation
- Execute tasks step by step with clear progress indicators
- Check for duplicate functionality across existing features, APIs, and common processes
- Provide context and reasoning for technical decisions to help users understand the approach

### Execution Workflow

1. **Analysis Phase:**

   - Summarize the task requirements clearly
   - Confirm rule compliance and identify any constraints
   - Identify all technical requirements and dependencies

2. **Implementation Phase:**

   - Follow established directory structure and naming conventions
   - Implement complete, production-ready solutions
   - Include all necessary imports, dependencies, and configurations

3. **Quality Assurance Phase:**

   - Implement comprehensive error handling (isolation → solution → verification → analysis)
   - Ensure code follows best practices and is maintainable
   - Verify all functionality works as expected

4. **Reporting Phase:**
   - Provide final confirmation of completed work
   - Document any important implementation details
   - Suggest next steps or improvements where relevant

## Tech Stack

### Frontend Core

- Next.js (Server Components) - Default rendering approach for SEO and performance
- TypeScript - Type safety and better developer experience
- Bun - Fast runtime and package manager

### UI Framework

- Shadcn/ui - Component library with consistent design system
- Tailwind CSS - Utility-first styling approach
- Radix UI - Accessible, unstyled UI primitives
- Lucide React - Consistent icon system

### Authentication & Backend

- Clerk - Complete authentication solution with user management
- Prisma - Type-safe ORM for database operations
- Supabase - Backend-as-a-Service with PostgreSQL, real-time features, and storage

### Testing

- Vitest - Fast unit and integration testing
- React Testing Library - Component testing with user-centric approach
- Playwright - End-to-end testing for critical user flows
- MSW - API mocking for reliable testing

### Additional Tools

- Server Actions - Type-safe server-side operations
- Zod - Runtime type validation for forms and APIs
- date-fns - Lightweight date manipulation library
- Stripe - Payment processing integration
- Vercel - Deployment platform optimized for Next.js

## MCP (Model Context Protocol)

### Next.js DevTools

- **目的**: Next.js 16 以降の開発サーバーと統合し、リアルタイムでアプリケーションの内部情報にアクセスする
- **使用コンテキスト**: エラー検出、ライブ状態クエリ、ページメタデータの取得、Server Actions の検査などに使用する
- **ベストプラクティス**: 開発サーバー起動後、エージェントにエラーや実装箇所を質問することで、コンテキストを踏まえた正確な提案が得られる

### Chrome DevTools

- **目的**: Chrome DevTools を MCP 経由で操作し、ブラウザの開発者ツール機能をエージェントから利用可能にする
- **使用コンテキスト**: パフォーマンス分析、ネットワークトラフィック監視、コンソールログ取得、DOM 操作、デバッグ作業などに使用する
- **ベストプラクティス**: フロントエンドのパフォーマンスボトルネック特定やブラウザ固有の問題調査に活用する

### Playwright

- **目的**: ブラウザの自動操作とエンドツーエンドテストを行うためのフレームワーク
- **使用コンテキスト**: 機能実装後、ユーザーフローを自動テストし、スクリーンショットを取得して UI の動作を検証する
- **ベストプラクティス**: 重要なユーザージャーニーやビジュアル回帰テストに活用する

### Deepwiki

- **目的**: 外部ナレッジベースから GitHub リポジトリのドキュメントを検索する
- **使用コンテキスト**: ユーザーが外部のオープンソースプロジェクトの調査を明示的に依頼した場合のみ使用する
- **ベストプラクティス**: サードパーティライブラリやフレームワークの包括的な情報を収集するために活用する
- **利用可能なメソッド**: `read_wiki_structure`, `read_wiki_contents`, `ask_question`

### Supabase

- **目的**: PostgreSQL データベース、認証、ストレージ、リアルタイム API を提供する Backend-as-a-Service
- **使用コンテキスト**: CRUD 操作の実装や Row Level Security (RLS)ポリシーの設定により、セキュアなデータアクセスを提供する
- **ベストプラクティス**: 適切な RLS ポリシーを実装し、型安全なデータベース操作を行う

## Directory Structure

```sh
src/
├── app/              # Next.js App Router - routing and pages
├── components/
│   ├── ui/           # Shadcn/ui components - reusable UI primitives
│   └── layouts/      # Layout components for consistent page structure
├── hooks/            # Custom React hooks for shared logic
├── types/            # TypeScript type definitions
├── lib/
│   ├── constants/    # Application constants and configuration
│   └── utils/        # Utility functions and helpers
└── tests/
    ├── unit/         # Unit tests for individual functions/components
    ├── integration/  # Integration tests for component interactions
    └── e2e/          # End-to-end tests for complete user flows
```

### File Naming Conventions

- **Pages**: `page.tsx` - Next.js App Router page components
- **Layouts**: `layout.tsx` - Shared layout components for route groups
- **Loading**: `loading.tsx` - Loading UI for route segments
- **Errors**: `error.tsx` - Error boundary components for route segments
- **APIs**: `route.ts` - API route handlers for server endpoints

### Component Design Principles

- **Server Components (default)**: Use for data fetching, SEO optimization, and static content rendering
- **Client Components (when needed)**: Use only when requiring browser APIs, event listeners, or React hooks
- **Composition over inheritance**: Build complex UIs by composing smaller, focused components

### API Design Patterns

- **No GET APIs**: Use Server Components for data fetching instead of API routes
- **Server Actions preferred**: Use Server Actions for form submissions and mutations
- **API routes for external integrations**: POST/PATCH/PUT/DELETE only for webhooks and third-party integrations
- **Type safety**: Always use Zod schemas for request/response validation

## UI/UX Guidelines

### Critical Constraints

- **No unauthorized UI changes**: Never modify existing UI/UX elements without explicit user approval
- **Design consistency**: All layout, color, font, and spacing changes require explicit approval
- **Component reuse**: Always prioritize using existing components over creating new ones
- **Minimal customization**: Keep custom styling to an absolute minimum unless specifically requested

### Design System Principles

- **Mobile-first responsive design**: Ensure all interfaces work seamlessly across device sizes
- **Accessibility compliance**: Follow WAI-ARIA guidelines for inclusive user experiences
- **Keyboard navigation**: Implement full keyboard accessibility for all interactive elements
- **Visual accessibility**: Maintain proper contrast ratios and readable typography

### Styling Standards

- **Tailwind CSS approach**: Use utility classes with custom components via `@layer` directive
- **Naming convention**: Use `kebab-case` for custom CSS classes and component names
- **Dark mode support**: Implement system-synchronized dark mode using Tailwind's dark: variants
- **Performance optimization**: Minimize custom CSS and leverage Tailwind's purging capabilities
